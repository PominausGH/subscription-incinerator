# MVP Phase 1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build core MVP with manual subscription tracking, email reminders, and basic authentication

**Architecture:** Next.js 14 app with App Router, Prisma ORM for PostgreSQL, NextAuth for authentication, BullMQ for background jobs, Resend for emails, Stripe for payments

**Tech Stack:** Next.js 14, TypeScript, Prisma, PostgreSQL, Redis, BullMQ, NextAuth, Resend, Stripe, Tailwind CSS

---

## Prerequisites

- Node.js 20+
- PostgreSQL (local or Docker)
- Redis (local or Docker)
- Stripe account (test mode)
- Resend account

---

## Task 1: Project Initialization

**Files:**
- Create: `package.json`
- Create: `.gitignore`
- Create: `.env.example`
- Create: `tsconfig.json`
- Create: `next.config.js`
- Create: `tailwind.config.ts`

**Step 1: Initialize Next.js project**

Run:
```bash
npx create-next-app@latest . --typescript --tailwind --app --no-src-dir --import-alias "@/*"
```

Expected: Project scaffolding created

**Step 2: Install core dependencies**

Run:
```bash
npm install @prisma/client next-auth@beta resend bullmq ioredis stripe zod
npm install -D prisma @types/node tsx
```

Expected: Dependencies installed

**Step 3: Create environment template**

Create: `.env.example`

```bash
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/subscription_incinerator"

# Redis
REDIS_URL="redis://localhost:6379"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="generate-with-openssl-rand-base64-32"

# Resend
RESEND_API_KEY="re_xxxxx"

# Stripe
STRIPE_SECRET_KEY="sk_test_xxxxx"
STRIPE_WEBHOOK_SECRET="whsec_xxxxx"
STRIPE_PREMIUM_PRICE_ID="price_xxxxx"

# App
APP_URL="http://localhost:3000"
```

**Step 4: Copy to .env.local**

Run:
```bash
cp .env.example .env.local
```

**Step 5: Update .gitignore**

Create: `.gitignore`

```
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# prisma
prisma/migrations/*_init
```

**Step 6: Commit**

Run:
```bash
git add .
git commit -m "chore: initialize Next.js project with dependencies"
```

---

## Task 2: Database Schema Setup

**Files:**
- Create: `prisma/schema.prisma`
- Create: `lib/db/client.ts`

**Step 1: Initialize Prisma**

Run:
```bash
npx prisma init
```

Expected: `prisma/schema.prisma` created

**Step 2: Define database schema**

Modify: `prisma/schema.prisma`

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // OAuth tokens (encrypted)
  oauthTokens     Json?   @map("oauth_tokens")
  emailProvider   String? @map("email_provider") // 'gmail', 'outlook', null

  // Subscription tier
  tier            String  @default("free") // 'free', 'premium'

  // Notification preferences
  notificationPreferences Json @default("{\"email\": true, \"push\": true, \"sms\": false}") @map("notification_preferences")

  // Phone (for SMS)
  phoneNumber     String?  @map("phone_number")
  phoneVerified   Boolean  @default(false) @map("phone_verified")

  // Stripe
  stripeCustomerId String? @unique @map("stripe_customer_id")

  // Relations
  subscriptions     Subscription[]
  pushSubscriptions PushSubscription[]
  accounts          Account[]
  sessions          Session[]

  @@map("users")
}

// NextAuth models
model Account {
  id                String  @id @default(uuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Subscription {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  serviceName String   @map("service_name")
  status      String   @default("active") // 'trial', 'active', 'cancelled', 'expired'

  billingCycle String?   @map("billing_cycle") // 'monthly', 'yearly', 'custom'
  amount       Decimal?  @db.Decimal(10, 2)
  currency     String    @default("USD")

  trialEndsAt     DateTime? @map("trial_ends_at")
  nextBillingDate DateTime? @map("next_billing_date")

  cancellationUrl    String?  @map("cancellation_url") @db.Text
  autoCancelEnabled  Boolean  @default(false) @map("auto_cancel_enabled")

  detectedFrom  String? @map("detected_from") // 'email_scan', 'manual', 'api'
  rawEmailData  Json?   @map("raw_email_data")
  externalId    String? @map("external_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  reminders            Reminder[]
  cancellationAttempts CancellationAttempt[]

  @@index([userId])
  @@index([userId, status])
  @@index([nextBillingDate])
  @@map("subscriptions")
}

model Reminder {
  id             String    @id @default(uuid())
  subscriptionId String    @map("subscription_id")
  reminderType   String    @map("reminder_type") // 'trial_ending', 'billing_upcoming', 'cancellation_failed'
  scheduledFor   DateTime  @map("scheduled_for")
  sentAt         DateTime? @map("sent_at")
  channelsUsed   String[]  @map("channels_used")
  jobId          String?   @map("job_id")
  status         String    @default("pending") // 'pending', 'sent', 'failed'
  createdAt      DateTime  @default(now()) @map("created_at")

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([scheduledFor, status])
  @@map("reminders")
}

model CancellationAttempt {
  id              String    @id @default(uuid())
  subscriptionId  String    @map("subscription_id")
  method          String?   // 'api', 'automation', 'manual_script'
  status          String    @default("pending") // 'pending', 'success', 'failed', 'requires_manual'
  errorMessage    String?   @map("error_message") @db.Text
  credentialsUsed Json?     @map("credentials_used")
  attemptedAt     DateTime  @default(now()) @map("attempted_at")
  completedAt     DateTime? @map("completed_at")

  // Relations
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@map("cancellation_attempts")
}

model ServiceConfig {
  id          String   @id @default(uuid())
  serviceName String   @unique @map("service_name")

  hasApi          Boolean @default(false) @map("has_api")
  apiEndpoint     String? @map("api_endpoint") @db.Text
  apiAuthType     String? @map("api_auth_type")

  loginUrl              String? @map("login_url") @db.Text
  cancellationUrl       String? @map("cancellation_url") @db.Text
  cancelButtonSelector  String? @map("cancel_button_selector")
  confirmSelector       String? @map("confirm_selector")
  successIndicator      String? @map("success_indicator")

  cancellationInstructions Json?   @map("cancellation_instructions")
  emailPatterns            Json?   @map("email_patterns")

  logoUrl    String? @map("logo_url") @db.Text
  supportUrl String? @map("support_url") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("service_configs")
}

model PushSubscription {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  endpointData Json     @map("endpoint_data")
  active       Boolean  @default(true)
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, active])
  @@map("push_subscriptions")
}
```

**Step 3: Create database client**

Create: `lib/db/client.ts`

```typescript
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const db = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
})

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db
```

**Step 4: Run migration**

Run:
```bash
npx prisma migrate dev --name init
npx prisma generate
```

Expected: Database tables created, Prisma Client generated

**Step 5: Commit**

Run:
```bash
git add prisma/ lib/db/
git commit -m "feat: add database schema and Prisma setup"
```

---

## Task 3: Authentication Setup

**Files:**
- Create: `lib/auth.ts`
- Create: `app/api/auth/[...nextauth]/route.ts`
- Create: `middleware.ts`

**Step 1: Configure NextAuth**

Create: `lib/auth.ts`

```typescript
import { NextAuthOptions } from "next-auth"
import { PrismaAdapter } from "@auth/prisma-adapter"
import EmailProvider from "next-auth/providers/email"
import { db } from "@/lib/db/client"

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(db),
  providers: [
    EmailProvider({
      server: {
        host: process.env.EMAIL_SERVER_HOST,
        port: Number(process.env.EMAIL_SERVER_PORT),
        auth: {
          user: process.env.EMAIL_SERVER_USER,
          pass: process.env.EMAIL_SERVER_PASSWORD,
        },
      },
      from: process.env.EMAIL_FROM || 'noreply@subincinerator.com',
    }),
  ],
  pages: {
    signIn: '/login',
    verifyRequest: '/verify-request',
    error: '/error',
  },
  callbacks: {
    async session({ session, user }) {
      if (session.user) {
        session.user.id = user.id
        // @ts-ignore
        session.user.tier = user.tier
      }
      return session
    },
  },
  session: {
    strategy: "database",
  },
}
```

**Step 2: Create auth API route**

Create: `app/api/auth/[...nextauth]/route.ts`

```typescript
import NextAuth from "next-auth"
import { authOptions } from "@/lib/auth"

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
```

**Step 3: Add middleware for protected routes**

Create: `middleware.ts`

```typescript
export { default } from "next-auth/middleware"

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/subscriptions/:path*',
    '/settings/:path*',
    '/api/subscriptions/:path*',
    '/api/reminders/:path*',
  ],
}
```

**Step 4: Install NextAuth Prisma adapter**

Run:
```bash
npm install @auth/prisma-adapter
```

**Step 5: Commit**

Run:
```bash
git add lib/auth.ts app/api/auth/ middleware.ts
git commit -m "feat: configure NextAuth with email magic link"
```

---

## Task 4: Login Page UI

**Files:**
- Create: `app/login/page.tsx`
- Create: `components/ui/button.tsx`
- Create: `components/ui/input.tsx`
- Create: `components/auth/login-form.tsx`

**Step 1: Create button component**

Create: `components/ui/button.tsx`

```typescript
import * as React from "react"
import { cn } from "@/lib/utils"

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'outline' | 'ghost'
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', ...props }, ref) => {
    return (
      <button
        className={cn(
          "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2",
          "disabled:opacity-50 disabled:pointer-events-none",
          "px-4 py-2",
          variant === 'default' && "bg-blue-600 text-white hover:bg-blue-700",
          variant === 'outline' && "border border-gray-300 bg-white hover:bg-gray-50",
          variant === 'ghost' && "hover:bg-gray-100",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button }
```

**Step 2: Create input component**

Create: `components/ui/input.tsx`

```typescript
import * as React from "react"
import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm",
          "placeholder:text-gray-400",
          "focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent",
          "disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```

**Step 3: Create utils for class names**

Create: `lib/utils.ts`

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

Install dependencies:
```bash
npm install clsx tailwind-merge
```

**Step 4: Create login form component**

Create: `components/auth/login-form.tsx`

```typescript
'use client'

import { useState } from 'react'
import { signIn } from 'next-auth/react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

export function LoginForm() {
  const [email, setEmail] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [isSuccess, setIsSuccess] = useState(false)

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    setIsLoading(true)

    try {
      await signIn('email', { email, redirect: false })
      setIsSuccess(true)
    } catch (error) {
      console.error('Login error:', error)
    } finally {
      setIsLoading(false)
    }
  }

  if (isSuccess) {
    return (
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-2">Check your email</h2>
        <p className="text-gray-600">
          We sent a magic link to <strong>{email}</strong>
        </p>
      </div>
    )
  }

  return (
    <form onSubmit={onSubmit} className="space-y-4">
      <div>
        <label htmlFor="email" className="block text-sm font-medium text-gray-700 mb-1">
          Email address
        </label>
        <Input
          id="email"
          type="email"
          placeholder="you@example.com"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
          disabled={isLoading}
        />
      </div>
      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? 'Sending...' : 'Send magic link'}
      </Button>
    </form>
  )
}
```

**Step 5: Create login page**

Create: `app/login/page.tsx`

```typescript
import { LoginForm } from '@/components/auth/login-form'

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div className="text-center">
          <h1 className="text-4xl font-bold">ðŸ”¥</h1>
          <h2 className="mt-6 text-3xl font-extrabold text-gray-900">
            Subscription Incinerator
          </h2>
          <p className="mt-2 text-sm text-gray-600">
            Never pay for a forgotten trial again
          </p>
        </div>
        <div className="mt-8 bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10">
          <LoginForm />
        </div>
      </div>
    </div>
  )
}
```

**Step 6: Commit**

Run:
```bash
git add app/login/ components/ lib/utils.ts
git commit -m "feat: add login UI with magic link authentication"
```

---

## Task 5: Dashboard Layout

**Files:**
- Create: `app/dashboard/layout.tsx`
- Create: `components/dashboard/navbar.tsx`
- Create: `lib/session.ts`

**Step 1: Create session helper**

Create: `lib/session.ts`

```typescript
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth"
import { redirect } from "next/navigation"

export async function getCurrentUser() {
  const session = await getServerSession(authOptions)

  if (!session?.user) {
    redirect('/login')
  }

  return session.user
}
```

**Step 2: Create navbar component**

Create: `components/dashboard/navbar.tsx`

```typescript
'use client'

import Link from 'next/link'
import { signOut } from 'next-auth/react'
import { Button } from '@/components/ui/button'

export function Navbar({ userEmail }: { userEmail: string }) {
  return (
    <nav className="bg-white border-b border-gray-200">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          <div className="flex">
            <Link href="/dashboard" className="flex items-center">
              <span className="text-2xl">ðŸ”¥</span>
              <span className="ml-2 text-xl font-bold">Subscription Incinerator</span>
            </Link>
          </div>
          <div className="flex items-center space-x-4">
            <span className="text-sm text-gray-600">{userEmail}</span>
            <Button
              variant="ghost"
              onClick={() => signOut({ callbackUrl: '/login' })}
            >
              Sign out
            </Button>
          </div>
        </div>
      </div>
    </nav>
  )
}
```

**Step 3: Create dashboard layout**

Create: `app/dashboard/layout.tsx`

```typescript
import { getCurrentUser } from '@/lib/session'
import { Navbar } from '@/components/dashboard/navbar'

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const user = await getCurrentUser()

  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar userEmail={user.email!} />
      <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        {children}
      </main>
    </div>
  )
}
```

**Step 4: Commit**

Run:
```bash
git add app/dashboard/layout.tsx components/dashboard/ lib/session.ts
git commit -m "feat: add dashboard layout with navbar"
```

---

## Task 6: Manual Subscription Entry

**Files:**
- Create: `app/api/subscriptions/route.ts`
- Create: `lib/validations/subscription.ts`
- Create: `components/subscriptions/add-subscription-form.tsx`
- Create: `app/dashboard/page.tsx`

**Step 1: Create validation schema**

Create: `lib/validations/subscription.ts`

```typescript
import { z } from 'zod'

export const createSubscriptionSchema = z.object({
  serviceName: z.string().min(1, 'Service name is required').max(255),
  status: z.enum(['trial', 'active']).default('active'),
  billingCycle: z.enum(['monthly', 'yearly', 'custom']).optional(),
  amount: z.number().positive().optional(),
  currency: z.string().default('USD'),
  trialEndsAt: z.string().datetime().optional(),
  nextBillingDate: z.string().datetime().optional(),
  cancellationUrl: z.string().url().optional(),
})

export type CreateSubscriptionInput = z.infer<typeof createSubscriptionSchema>
```

**Step 2: Create subscription API route**

Create: `app/api/subscriptions/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { db } from '@/lib/db/client'
import { createSubscriptionSchema } from '@/lib/validations/subscription'

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await req.json()
    const validated = createSubscriptionSchema.parse(body)

    const subscription = await db.subscription.create({
      data: {
        userId: session.user.id,
        serviceName: validated.serviceName,
        status: validated.status,
        billingCycle: validated.billingCycle,
        amount: validated.amount,
        currency: validated.currency,
        trialEndsAt: validated.trialEndsAt ? new Date(validated.trialEndsAt) : null,
        nextBillingDate: validated.nextBillingDate ? new Date(validated.nextBillingDate) : null,
        cancellationUrl: validated.cancellationUrl,
        detectedFrom: 'manual',
      },
    })

    return NextResponse.json(subscription, { status: 201 })
  } catch (error) {
    console.error('Create subscription error:', error)

    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors }, { status: 400 })
    }

    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const subscriptions = await db.subscription.findMany({
      where: { userId: session.user.id },
      orderBy: { createdAt: 'desc' },
    })

    return NextResponse.json(subscriptions)
  } catch (error) {
    console.error('Get subscriptions error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

**Step 3: Create add subscription form**

Create: `components/subscriptions/add-subscription-form.tsx`

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

export function AddSubscriptionForm() {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [formData, setFormData] = useState({
    serviceName: '',
    status: 'active' as 'trial' | 'active',
    billingCycle: 'monthly' as 'monthly' | 'yearly',
    amount: '',
    trialEndsAt: '',
    nextBillingDate: '',
    cancellationUrl: '',
  })

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    setIsLoading(true)

    try {
      const payload = {
        serviceName: formData.serviceName,
        status: formData.status,
        billingCycle: formData.billingCycle,
        amount: formData.amount ? parseFloat(formData.amount) : undefined,
        trialEndsAt: formData.trialEndsAt ? new Date(formData.trialEndsAt).toISOString() : undefined,
        nextBillingDate: formData.nextBillingDate ? new Date(formData.nextBillingDate).toISOString() : undefined,
        cancellationUrl: formData.cancellationUrl || undefined,
      }

      const response = await fetch('/api/subscriptions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })

      if (!response.ok) {
        throw new Error('Failed to create subscription')
      }

      router.refresh()

      // Reset form
      setFormData({
        serviceName: '',
        status: 'active',
        billingCycle: 'monthly',
        amount: '',
        trialEndsAt: '',
        nextBillingDate: '',
        cancellationUrl: '',
      })
    } catch (error) {
      console.error('Submit error:', error)
      alert('Failed to add subscription')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={onSubmit} className="space-y-4 bg-white p-6 rounded-lg shadow">
      <h3 className="text-lg font-medium">Add Subscription</h3>

      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
        <div>
          <label htmlFor="serviceName" className="block text-sm font-medium text-gray-700 mb-1">
            Service Name *
          </label>
          <Input
            id="serviceName"
            value={formData.serviceName}
            onChange={(e) => setFormData({ ...formData, serviceName: e.target.value })}
            placeholder="Netflix, Spotify, etc."
            required
          />
        </div>

        <div>
          <label htmlFor="status" className="block text-sm font-medium text-gray-700 mb-1">
            Status
          </label>
          <select
            id="status"
            value={formData.status}
            onChange={(e) => setFormData({ ...formData, status: e.target.value as 'trial' | 'active' })}
            className="flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm"
          >
            <option value="trial">Free Trial</option>
            <option value="active">Active</option>
          </select>
        </div>

        <div>
          <label htmlFor="amount" className="block text-sm font-medium text-gray-700 mb-1">
            Amount ($)
          </label>
          <Input
            id="amount"
            type="number"
            step="0.01"
            value={formData.amount}
            onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
            placeholder="9.99"
          />
        </div>

        <div>
          <label htmlFor="billingCycle" className="block text-sm font-medium text-gray-700 mb-1">
            Billing Cycle
          </label>
          <select
            id="billingCycle"
            value={formData.billingCycle}
            onChange={(e) => setFormData({ ...formData, billingCycle: e.target.value as 'monthly' | 'yearly' })}
            className="flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm"
          >
            <option value="monthly">Monthly</option>
            <option value="yearly">Yearly</option>
          </select>
        </div>

        {formData.status === 'trial' && (
          <div>
            <label htmlFor="trialEndsAt" className="block text-sm font-medium text-gray-700 mb-1">
              Trial Ends
            </label>
            <Input
              id="trialEndsAt"
              type="datetime-local"
              value={formData.trialEndsAt}
              onChange={(e) => setFormData({ ...formData, trialEndsAt: e.target.value })}
            />
          </div>
        )}

        <div>
          <label htmlFor="nextBillingDate" className="block text-sm font-medium text-gray-700 mb-1">
            Next Billing Date
          </label>
          <Input
            id="nextBillingDate"
            type="datetime-local"
            value={formData.nextBillingDate}
            onChange={(e) => setFormData({ ...formData, nextBillingDate: e.target.value })}
          />
        </div>

        <div className="sm:col-span-2">
          <label htmlFor="cancellationUrl" className="block text-sm font-medium text-gray-700 mb-1">
            Cancellation URL
          </label>
          <Input
            id="cancellationUrl"
            type="url"
            value={formData.cancellationUrl}
            onChange={(e) => setFormData({ ...formData, cancellationUrl: e.target.value })}
            placeholder="https://example.com/cancel"
          />
        </div>
      </div>

      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Adding...' : 'Add Subscription'}
      </Button>
    </form>
  )
}
```

**Step 4: Create dashboard page**

Create: `app/dashboard/page.tsx`

```typescript
import { db } from '@/lib/db/client'
import { getCurrentUser } from '@/lib/session'
import { AddSubscriptionForm } from '@/components/subscriptions/add-subscription-form'

export default async function DashboardPage() {
  const user = await getCurrentUser()

  const subscriptions = await db.subscription.findMany({
    where: { userId: user.id },
    orderBy: { createdAt: 'desc' },
  })

  return (
    <div className="px-4 sm:px-0">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">Dashboard</h1>
        <p className="mt-2 text-sm text-gray-600">
          Track and manage your subscriptions
        </p>
      </div>

      <div className="mb-8">
        <AddSubscriptionForm />
      </div>

      <div>
        <h2 className="text-xl font-semibold mb-4">Your Subscriptions ({subscriptions.length})</h2>

        {subscriptions.length === 0 ? (
          <div className="bg-white rounded-lg shadow p-8 text-center text-gray-500">
            No subscriptions yet. Add your first one above!
          </div>
        ) : (
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {subscriptions.map((sub) => (
              <div key={sub.id} className="bg-white rounded-lg shadow p-6">
                <div className="flex justify-between items-start mb-4">
                  <h3 className="text-lg font-semibold">{sub.serviceName}</h3>
                  <span className={`px-2 py-1 text-xs rounded-full ${
                    sub.status === 'trial' ? 'bg-yellow-100 text-yellow-800' :
                    sub.status === 'active' ? 'bg-green-100 text-green-800' :
                    'bg-gray-100 text-gray-800'
                  }`}>
                    {sub.status}
                  </span>
                </div>

                {sub.amount && (
                  <p className="text-2xl font-bold mb-2">
                    ${sub.amount.toString()}/{sub.billingCycle}
                  </p>
                )}

                {sub.trialEndsAt && (
                  <p className="text-sm text-gray-600">
                    Trial ends: {new Date(sub.trialEndsAt).toLocaleDateString()}
                  </p>
                )}

                {sub.nextBillingDate && (
                  <p className="text-sm text-gray-600">
                    Next billing: {new Date(sub.nextBillingDate).toLocaleDateString()}
                  </p>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
```

**Step 5: Commit**

Run:
```bash
git add app/api/subscriptions/ app/dashboard/page.tsx components/subscriptions/ lib/validations/
git commit -m "feat: add manual subscription entry with form and API"
```

---

## Task 7: BullMQ Queue Setup

**Files:**
- Create: `lib/queue/client.ts`
- Create: `lib/queue/jobs.ts`
- Create: `workers/index.ts`
- Create: `workers/processors/reminder-sender.ts`
- Create: `package.json` (update scripts)

**Step 1: Create queue client**

Create: `lib/queue/client.ts`

```typescript
import { Queue } from 'bullmq'
import { Redis } from 'ioredis'

const connection = new Redis(process.env.REDIS_URL!, {
  maxRetriesPerRequest: null,
})

export const queues = {
  reminders: new Queue('reminders', {
    connection,
    defaultJobOptions: {
      attempts: 5,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
      removeOnComplete: 1000,
      removeOnFail: 5000,
    },
  }),
}
```

**Step 2: Create job type definitions**

Create: `lib/queue/jobs.ts`

```typescript
export enum JobType {
  SEND_REMINDER = 'send_reminder',
}

export interface SendReminderJob {
  reminderId: string
}

export type JobData = SendReminderJob
```

**Step 3: Create reminder processor**

Create: `workers/processors/reminder-sender.ts`

```typescript
import { Job } from 'bullmq'
import { db } from '@/lib/db/client'
import { SendReminderJob } from '@/lib/queue/jobs'
import { sendReminderEmail } from '@/lib/notifications/email'

export async function processReminderJob(job: Job<SendReminderJob>) {
  const { reminderId } = job.data

  console.log(`Processing reminder ${reminderId}`)

  const reminder = await db.reminder.findUnique({
    where: { id: reminderId },
    include: {
      subscription: {
        include: {
          user: true,
        },
      },
    },
  })

  if (!reminder) {
    throw new Error(`Reminder ${reminderId} not found`)
  }

  if (reminder.status !== 'pending') {
    console.log(`Reminder ${reminderId} already processed, skipping`)
    return
  }

  // Send email notification
  await sendReminderEmail(reminder)

  // Update reminder status
  await db.reminder.update({
    where: { id: reminderId },
    data: {
      status: 'sent',
      sentAt: new Date(),
      channelsUsed: ['email'],
    },
  })

  console.log(`Reminder ${reminderId} sent successfully`)
}
```

**Step 4: Create worker entry point**

Create: `workers/index.ts`

```typescript
import { Worker } from 'bullmq'
import { Redis } from 'ioredis'
import { processReminderJob } from './processors/reminder-sender'
import { SendReminderJob } from '@/lib/queue/jobs'

const connection = new Redis(process.env.REDIS_URL!, {
  maxRetriesPerRequest: null,
})

const reminderWorker = new Worker<SendReminderJob>(
  'reminders',
  async (job) => {
    await processReminderJob(job)
  },
  { connection }
)

reminderWorker.on('completed', (job) => {
  console.log(`Job ${job.id} completed`)
})

reminderWorker.on('failed', (job, err) => {
  console.error(`Job ${job?.id} failed:`, err)
})

console.log('Workers started successfully')

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing workers...')
  await reminderWorker.close()
  process.exit(0)
})
```

**Step 5: Update package.json scripts**

Modify: `package.json`

Add to `scripts`:
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "worker": "tsx watch workers/index.ts",
    "dev:all": "concurrently \"npm run dev\" \"npm run worker\""
  }
}
```

Install concurrently:
```bash
npm install -D concurrently
```

**Step 6: Commit**

Run:
```bash
git add lib/queue/ workers/ package.json
git commit -m "feat: add BullMQ queue setup with reminder worker"
```

---

## Task 8: Email Notification System

**Files:**
- Create: `lib/notifications/email.ts`
- Create: `lib/notifications/templates.ts`

**Step 1: Create email templates**

Create: `lib/notifications/templates.ts`

```typescript
import { Subscription, Reminder, User } from '@prisma/client'

type ReminderWithRelations = Reminder & {
  subscription: Subscription & {
    user: User
  }
}

export function getTrialEndingEmailTemplate(reminder: ReminderWithRelations) {
  const { subscription } = reminder
  const daysUntilEnd = Math.ceil(
    (new Date(subscription.trialEndsAt!).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
  )

  return {
    subject: `Trial ending soon: ${subscription.serviceName}`,
    html: `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { text-align: center; margin-bottom: 30px; }
            .emoji { font-size: 48px; }
            .alert-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 16px; margin: 20px 0; }
            .button { display: inline-block; background: #dc2626; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 10px 5px; }
            .button-secondary { background: #6b7280; }
            .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; font-size: 14px; color: #6b7280; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <div class="emoji">ðŸ”¥</div>
              <h1>Your trial is ending soon!</h1>
            </div>

            <div class="alert-box">
              <p><strong>${subscription.serviceName}</strong> free trial ends in <strong>${daysUntilEnd} day${daysUntilEnd !== 1 ? 's' : ''}</strong></p>
              ${subscription.amount ? `<p>You'll be charged <strong>$${subscription.amount}</strong> unless you cancel.</p>` : ''}
            </div>

            <p>What would you like to do?</p>

            <div style="text-align: center; margin: 30px 0;">
              <a href="${process.env.APP_URL}/subscriptions/${subscription.id}/cancel" class="button">
                Cancel Subscription
              </a>
              <a href="${process.env.APP_URL}/dashboard" class="button button-secondary">
                View Dashboard
              </a>
            </div>

            ${subscription.cancellationUrl ? `
              <p style="font-size: 14px; color: #6b7280;">
                Or cancel directly: <a href="${subscription.cancellationUrl}">${subscription.cancellationUrl}</a>
              </p>
            ` : ''}

            <div class="footer">
              <p>You're receiving this because you signed up for Subscription Incinerator.</p>
              <p><a href="${process.env.APP_URL}/settings">Manage notification preferences</a></p>
            </div>
          </div>
        </body>
      </html>
    `,
  }
}

export function getBillingUpcomingEmailTemplate(reminder: ReminderWithRelations) {
  const { subscription } = reminder
  const daysUntilBilling = Math.ceil(
    (new Date(subscription.nextBillingDate!).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
  )

  return {
    subject: `Upcoming charge: ${subscription.serviceName}`,
    html: `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { text-align: center; margin-bottom: 30px; }
            .emoji { font-size: 48px; }
            .info-box { background: #dbeafe; border-left: 4px solid #3b82f6; padding: 16px; margin: 20px 0; }
            .button { display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 10px 5px; }
            .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; font-size: 14px; color: #6b7280; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <div class="emoji">ðŸ’³</div>
              <h1>Upcoming charge reminder</h1>
            </div>

            <div class="info-box">
              <p><strong>${subscription.serviceName}</strong> will charge you in <strong>${daysUntilBilling} day${daysUntilBilling !== 1 ? 's' : ''}</strong></p>
              ${subscription.amount ? `<p>Amount: <strong>$${subscription.amount}</strong></p>` : ''}
            </div>

            <div style="text-align: center; margin: 30px 0;">
              <a href="${process.env.APP_URL}/dashboard" class="button">
                View Dashboard
              </a>
            </div>

            <div class="footer">
              <p>You're receiving this because you signed up for Subscription Incinerator.</p>
              <p><a href="${process.env.APP_URL}/settings">Manage notification preferences</a></p>
            </div>
          </div>
        </body>
      </html>
    `,
  }
}
```

**Step 2: Create email sender**

Create: `lib/notifications/email.ts`

```typescript
import { Resend } from 'resend'
import { Reminder, Subscription, User } from '@prisma/client'
import { getTrialEndingEmailTemplate, getBillingUpcomingEmailTemplate } from './templates'

const resend = new Resend(process.env.RESEND_API_KEY!)

type ReminderWithRelations = Reminder & {
  subscription: Subscription & {
    user: User
  }
}

export async function sendReminderEmail(reminder: ReminderWithRelations) {
  const { subscription } = reminder
  const { user } = subscription

  let template

  if (reminder.reminderType === 'trial_ending') {
    template = getTrialEndingEmailTemplate(reminder)
  } else if (reminder.reminderType === 'billing_upcoming') {
    template = getBillingUpcomingEmailTemplate(reminder)
  } else {
    throw new Error(`Unknown reminder type: ${reminder.reminderType}`)
  }

  const { data, error } = await resend.emails.send({
    from: 'Subscription Incinerator <reminders@subincinerator.com>',
    to: user.email,
    subject: template.subject,
    html: template.html,
  })

  if (error) {
    throw new Error(`Failed to send email: ${error.message}`)
  }

  return data
}
```

**Step 3: Install Resend**

Run:
```bash
npm install resend
```

**Step 4: Commit**

Run:
```bash
git add lib/notifications/
git commit -m "feat: add email notification system with Resend"
```

---

## Task 9: Reminder Scheduling

**Files:**
- Create: `lib/reminders/scheduler.ts`
- Modify: `app/api/subscriptions/route.ts` (add reminder scheduling)

**Step 1: Create reminder scheduler**

Create: `lib/reminders/scheduler.ts`

```typescript
import { db } from '@/lib/db/client'
import { queues } from '@/lib/queue/client'
import { Subscription } from '@prisma/client'

export async function scheduleTrialReminders(subscription: Subscription) {
  if (!subscription.trialEndsAt) {
    return
  }

  const trialEnd = new Date(subscription.trialEndsAt)
  const now = new Date()

  // Define reminder times: 24h, 3h, 1h before trial ends
  const reminderOffsets = [
    { hours: 24, type: '24 hours before' },
    { hours: 3, type: '3 hours before' },
    { hours: 1, type: '1 hour before' },
  ]

  for (const { hours, type } of reminderOffsets) {
    const scheduledFor = new Date(trialEnd.getTime() - hours * 60 * 60 * 1000)

    // Only schedule future reminders
    if (scheduledFor <= now) {
      console.log(`Skipping past reminder: ${type}`)
      continue
    }

    // Create reminder record
    const reminder = await db.reminder.create({
      data: {
        subscriptionId: subscription.id,
        reminderType: 'trial_ending',
        scheduledFor,
        status: 'pending',
      },
    })

    // Calculate delay in milliseconds
    const delay = scheduledFor.getTime() - now.getTime()

    // Queue the job
    const job = await queues.reminders.add(
      'send_reminder',
      { reminderId: reminder.id },
      { delay }
    )

    // Store job ID for potential cancellation
    await db.reminder.update({
      where: { id: reminder.id },
      data: { jobId: job.id },
    })

    console.log(`Scheduled reminder ${reminder.id} for ${scheduledFor.toISOString()}`)
  }
}

export async function scheduleBillingReminders(subscription: Subscription) {
  if (!subscription.nextBillingDate) {
    return
  }

  const billingDate = new Date(subscription.nextBillingDate)
  const now = new Date()

  // Define reminder times: 7 days, 24h before billing
  const reminderOffsets = [
    { days: 7, type: '7 days before' },
    { days: 1, type: '24 hours before' },
  ]

  for (const { days, type } of reminderOffsets) {
    const scheduledFor = new Date(billingDate.getTime() - days * 24 * 60 * 60 * 1000)

    // Only schedule future reminders
    if (scheduledFor <= now) {
      console.log(`Skipping past reminder: ${type}`)
      continue
    }

    // Create reminder record
    const reminder = await db.reminder.create({
      data: {
        subscriptionId: subscription.id,
        reminderType: 'billing_upcoming',
        scheduledFor,
        status: 'pending',
      },
    })

    // Calculate delay in milliseconds
    const delay = scheduledFor.getTime() - now.getTime()

    // Queue the job
    const job = await queues.reminders.add(
      'send_reminder',
      { reminderId: reminder.id },
      { delay }
    )

    // Store job ID
    await db.reminder.update({
      where: { id: reminder.id },
      data: { jobId: job.id },
    })

    console.log(`Scheduled reminder ${reminder.id} for ${scheduledFor.toISOString()}`)
  }
}
```

**Step 2: Update subscription API to schedule reminders**

Modify: `app/api/subscriptions/route.ts`

Add imports:
```typescript
import { scheduleTrialReminders, scheduleBillingReminders } from '@/lib/reminders/scheduler'
```

Update POST handler, after creating subscription:
```typescript
    const subscription = await db.subscription.create({
      data: {
        userId: session.user.id,
        serviceName: validated.serviceName,
        status: validated.status,
        billingCycle: validated.billingCycle,
        amount: validated.amount,
        currency: validated.currency,
        trialEndsAt: validated.trialEndsAt ? new Date(validated.trialEndsAt) : null,
        nextBillingDate: validated.nextBillingDate ? new Date(validated.nextBillingDate) : null,
        cancellationUrl: validated.cancellationUrl,
        detectedFrom: 'manual',
      },
    })

    // Schedule reminders
    if (subscription.trialEndsAt) {
      await scheduleTrialReminders(subscription)
    }
    if (subscription.nextBillingDate) {
      await scheduleBillingReminders(subscription)
    }

    return NextResponse.json(subscription, { status: 201 })
```

**Step 3: Commit**

Run:
```bash
git add lib/reminders/ app/api/subscriptions/route.ts
git commit -m "feat: add reminder scheduling for trials and billing"
```

---

## Task 10: Manual Cancellation Instructions

**Files:**
- Create: `lib/services/seed-configs.ts`
- Create: `app/api/subscriptions/[id]/cancel-instructions/route.ts`
- Create: `components/subscriptions/cancellation-wizard.tsx`
- Create: `app/subscriptions/[id]/cancel/page.tsx`

**Step 1: Create service config seeder**

Create: `lib/services/seed-configs.ts`

```typescript
import { db } from '@/lib/db/client'

const SERVICE_CONFIGS = [
  {
    serviceName: 'Netflix',
    cancellationUrl: 'https://www.netflix.com/cancelplan',
    supportUrl: 'https://help.netflix.com/en/node/407',
    logoUrl: 'https://www.netflix.com/favicon.ico',
    cancellationInstructions: [
      'Go to netflix.com and sign in',
      'Click on your profile icon in the top right',
      'Select "Account"',
      'Under "Membership & Billing", click "Cancel Membership"',
      'Confirm cancellation',
      'You\'ll receive an email confirmation',
    ],
  },
  {
    serviceName: 'Spotify',
    cancellationUrl: 'https://www.spotify.com/account/subscription/',
    supportUrl: 'https://support.spotify.com/article/cancel-subscription/',
    logoUrl: 'https://www.spotify.com/favicon.ico',
    cancellationInstructions: [
      'Go to spotify.com/account',
      'Click "Manage Plan" or "Change Plan"',
      'Scroll down and click "Cancel Premium"',
      'Follow the prompts to confirm',
      'Your premium will remain active until the end of your billing cycle',
    ],
  },
  {
    serviceName: 'Disney+',
    cancellationUrl: 'https://www.disneyplus.com/account',
    supportUrl: 'https://help.disneyplus.com/',
    logoUrl: 'https://www.disneyplus.com/favicon.ico',
    cancellationInstructions: [
      'Go to disneyplus.com and sign in',
      'Click on your profile',
      'Select "Account"',
      'Click "Billing Details"',
      'Click "Cancel Subscription"',
      'Confirm cancellation',
    ],
  },
  {
    serviceName: 'HBO Max',
    cancellationUrl: 'https://www.max.com/account',
    supportUrl: 'https://help.max.com/',
    logoUrl: 'https://www.max.com/favicon.ico',
    cancellationInstructions: [
      'Go to max.com and sign in',
      'Click your profile icon',
      'Select "Account"',
      'Under "Subscription", click "Manage Subscription"',
      'Click "Cancel Subscription"',
      'Follow prompts to confirm',
    ],
  },
  {
    serviceName: 'Amazon Prime',
    cancellationUrl: 'https://www.amazon.com/mc',
    supportUrl: 'https://www.amazon.com/gp/help/customer/display.html',
    logoUrl: 'https://www.amazon.com/favicon.ico',
    cancellationInstructions: [
      'Go to amazon.com/mc',
      'Sign in if needed',
      'Click "Update, cancel and more" under your membership',
      'Click "End membership"',
      'Confirm cancellation',
      'You can continue using Prime until the end of your billing period',
    ],
  },
]

export async function seedServiceConfigs() {
  for (const config of SERVICE_CONFIGS) {
    await db.serviceConfig.upsert({
      where: { serviceName: config.serviceName },
      update: config,
      create: config,
    })
  }

  console.log(`Seeded ${SERVICE_CONFIGS.length} service configs`)
}

// Run this manually or in a migration
if (require.main === module) {
  seedServiceConfigs()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error)
      process.exit(1)
    })
}
```

**Step 2: Run seed script**

Run:
```bash
tsx lib/services/seed-configs.ts
```

Expected: Service configs created in database

**Step 3: Create cancel instructions API**

Create: `app/api/subscriptions/[id]/cancel-instructions/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { db } from '@/lib/db/client'

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const subscription = await db.subscription.findUnique({
      where: { id: params.id },
    })

    if (!subscription) {
      return NextResponse.json({ error: 'Subscription not found' }, { status: 404 })
    }

    if (subscription.userId !== session.user.id) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Try to find service config
    const serviceConfig = await db.serviceConfig.findUnique({
      where: { serviceName: subscription.serviceName },
    })

    if (serviceConfig?.cancellationInstructions) {
      return NextResponse.json({
        service: subscription.serviceName,
        instructions: serviceConfig.cancellationInstructions,
        cancellationUrl: serviceConfig.cancellationUrl,
        supportUrl: serviceConfig.supportUrl,
      })
    }

    // Generic fallback
    return NextResponse.json({
      service: subscription.serviceName,
      instructions: [
        `Visit the ${subscription.serviceName} website or app`,
        'Navigate to your account settings',
        'Look for subscription or billing settings',
        'Find the cancel or manage subscription option',
        'Follow the prompts to cancel',
        'Save any confirmation emails or numbers',
      ],
      cancellationUrl: subscription.cancellationUrl,
      supportUrl: null,
    })
  } catch (error) {
    console.error('Get cancel instructions error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

**Step 4: Create cancellation wizard component**

Create: `components/subscriptions/cancellation-wizard.tsx`

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'

interface CancellationInstructions {
  service: string
  instructions: string[]
  cancellationUrl?: string | null
  supportUrl?: string | null
}

export function CancellationWizard({
  subscriptionId,
  serviceName,
}: {
  subscriptionId: string
  serviceName: string
}) {
  const [instructions, setInstructions] = useState<CancellationInstructions | null>(null)
  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set())
  const [isLoading, setIsLoading] = useState(false)

  async function loadInstructions() {
    setIsLoading(true)
    try {
      const response = await fetch(`/api/subscriptions/${subscriptionId}/cancel-instructions`)
      const data = await response.json()
      setInstructions(data)
    } catch (error) {
      console.error('Load instructions error:', error)
      alert('Failed to load cancellation instructions')
    } finally {
      setIsLoading(false)
    }
  }

  function toggleStep(index: number) {
    const newCompleted = new Set(completedSteps)
    if (newCompleted.has(index)) {
      newCompleted.delete(index)
    } else {
      newCompleted.add(index)
    }
    setCompletedSteps(newCompleted)
  }

  if (!instructions) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-2xl font-bold mb-4">Cancel {serviceName}</h2>
        <p className="text-gray-600 mb-6">
          We'll provide you with step-by-step instructions to cancel your subscription.
        </p>
        <Button onClick={loadInstructions} disabled={isLoading}>
          {isLoading ? 'Loading...' : 'Show Cancellation Instructions'}
        </Button>
      </div>
    )
  }

  const allCompleted = completedSteps.size === instructions.instructions.length

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-2xl font-bold mb-4">Cancel {instructions.service}</h2>

      {instructions.cancellationUrl && (
        <div className="mb-6">
          <a
            href={instructions.cancellationUrl}
            target="_blank"
            rel="noopener noreferrer"
            className="inline-flex items-center text-blue-600 hover:text-blue-700"
          >
            Open cancellation page â†’
          </a>
        </div>
      )}

      <div className="space-y-4 mb-6">
        {instructions.instructions.map((instruction, index) => (
          <div
            key={index}
            className={`flex items-start gap-3 p-4 rounded-lg border ${
              completedSteps.has(index)
                ? 'bg-green-50 border-green-200'
                : 'bg-gray-50 border-gray-200'
            }`}
          >
            <input
              type="checkbox"
              checked={completedSteps.has(index)}
              onChange={() => toggleStep(index)}
              className="mt-1 h-5 w-5 rounded border-gray-300"
            />
            <div className="flex-1">
              <span className="font-medium text-gray-900">Step {index + 1}</span>
              <p className={completedSteps.has(index) ? 'line-through text-gray-500' : ''}>
                {instruction}
              </p>
            </div>
          </div>
        ))}
      </div>

      {allCompleted && (
        <div className="bg-green-100 border border-green-200 rounded-lg p-4 mb-6">
          <p className="text-green-800 font-medium">
            âœ“ Great! Make sure to save any confirmation emails.
          </p>
        </div>
      )}

      {instructions.supportUrl && (
        <p className="text-sm text-gray-600">
          Need help?{' '}
          <a
            href={instructions.supportUrl}
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-600 hover:text-blue-700"
          >
            Visit support page
          </a>
        </p>
      )}
    </div>
  )
}
```

**Step 5: Create cancel page**

Create: `app/subscriptions/[id]/cancel/page.tsx`

```typescript
import { redirect } from 'next/navigation'
import { db } from '@/lib/db/client'
import { getCurrentUser } from '@/lib/session'
import { CancellationWizard } from '@/components/subscriptions/cancellation-wizard'

export default async function CancelSubscriptionPage({
  params,
}: {
  params: { id: string }
}) {
  const user = await getCurrentUser()

  const subscription = await db.subscription.findUnique({
    where: { id: params.id },
  })

  if (!subscription || subscription.userId !== user.id) {
    redirect('/dashboard')
  }

  return (
    <div className="min-h-screen bg-gray-50 py-12">
      <div className="max-w-3xl mx-auto px-4">
        <CancellationWizard
          subscriptionId={subscription.id}
          serviceName={subscription.serviceName}
        />
      </div>
    </div>
  )
}
```

**Step 6: Commit**

Run:
```bash
git add lib/services/ app/api/subscriptions/ app/subscriptions/ components/subscriptions/cancellation-wizard.tsx
git commit -m "feat: add manual cancellation instructions with wizard UI"
```

---

## Task 11: Development Environment Setup

**Files:**
- Create: `docker-compose.yml`
- Create: `README.md`
- Modify: `.env.example`

**Step 1: Create Docker Compose for local development**

Create: `docker-compose.yml`

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: subscription_incinerator
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

**Step 2: Create README**

Create: `README.md`

```markdown
# Subscription Incinerator

Never pay for a forgotten free trial again.

## Features (MVP Phase 1)

- âœ… Magic link authentication
- âœ… Manual subscription tracking
- âœ… Email reminders (24h, 3h, 1h before trial ends)
- âœ… Manual cancellation instructions
- âœ… Dashboard with subscription overview

## Tech Stack

- **Frontend:** Next.js 14, React, TypeScript, Tailwind CSS
- **Backend:** Next.js API Routes, Prisma ORM
- **Database:** PostgreSQL
- **Queue:** BullMQ + Redis
- **Notifications:** Resend (email)
- **Auth:** NextAuth.js

## Getting Started

### Prerequisites

- Node.js 20+
- Docker & Docker Compose

### Setup

1. **Clone and install dependencies:**

```bash
npm install
```

2. **Start PostgreSQL and Redis:**

```bash
docker-compose up -d
```

3. **Set up environment variables:**

```bash
cp .env.example .env.local
```

Edit `.env.local` and add:
- `NEXTAUTH_SECRET`: Generate with `openssl rand -base64 32`
- `RESEND_API_KEY`: Get from https://resend.com

4. **Run database migrations:**

```bash
npx prisma migrate dev
npx prisma generate
```

5. **Seed service configs:**

```bash
tsx lib/services/seed-configs.ts
```

6. **Start development servers:**

```bash
npm run dev:all
```

This runs both the Next.js app (http://localhost:3000) and the worker process.

### Development

- Web app: `npm run dev`
- Worker only: `npm run worker`
- Both: `npm run dev:all`

### Database

- View database: `npx prisma studio`
- Create migration: `npx prisma migrate dev --name <name>`
- Reset database: `npx prisma migrate reset`

## Project Structure

```
â”œâ”€â”€ app/                    # Next.js app directory
â”‚   â”œâ”€â”€ api/               # API routes
â”‚   â”œâ”€â”€ dashboard/         # Dashboard pages
â”‚   â””â”€â”€ login/             # Auth pages
â”œâ”€â”€ components/            # React components
â”œâ”€â”€ lib/                   # Shared utilities
â”‚   â”œâ”€â”€ db/               # Database client
â”‚   â”œâ”€â”€ notifications/    # Email/SMS/Push
â”‚   â”œâ”€â”€ queue/            # BullMQ setup
â”‚   â””â”€â”€ reminders/        # Reminder scheduling
â”œâ”€â”€ workers/               # Background job processors
â”œâ”€â”€ prisma/               # Database schema
â””â”€â”€ docs/                 # Design documents
```

## Contributing

See `docs/plans/` for implementation plans and design documents.

## License

MIT
```

**Step 3: Update .env.example**

Modify: `.env.example`

```bash
# Database
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/subscription_incinerator"

# Redis
REDIS_URL="redis://localhost:6379"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="generate-with-openssl-rand-base64-32"

# Resend (email)
RESEND_API_KEY="re_xxxxx"

# App
APP_URL="http://localhost:3000"

# Optional: Email provider for magic links
EMAIL_SERVER_HOST="smtp.resend.com"
EMAIL_SERVER_PORT="587"
EMAIL_SERVER_USER="resend"
EMAIL_SERVER_PASSWORD="your-resend-api-key"
EMAIL_FROM="noreply@subincinerator.com"
```

**Step 4: Commit**

Run:
```bash
git add docker-compose.yml README.md .env.example
git commit -m "docs: add development setup with Docker Compose and README"
```

---

## Task 12: Testing Setup

**Files:**
- Create: `jest.config.js`
- Create: `jest.setup.js`
- Create: `lib/test-utils.ts`
- Create: `__tests__/lib/reminders/scheduler.test.ts`

**Step 1: Install testing dependencies**

Run:
```bash
npm install -D jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom @types/jest
```

**Step 2: Create Jest config**

Create: `jest.config.js`

```javascript
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  testMatch: ['**/__tests__/**/*.test.ts', '**/__tests__/**/*.test.tsx'],
}

module.exports = createJestConfig(customJestConfig)
```

**Step 3: Create Jest setup**

Create: `jest.setup.js`

```javascript
import '@testing-library/jest-dom'
```

**Step 4: Create test utilities**

Create: `lib/test-utils.ts`

```typescript
import { PrismaClient } from '@prisma/client'

export const mockUser = {
  id: 'test-user-id',
  email: 'test@example.com',
  name: 'Test User',
  tier: 'free',
}

export const mockSubscription = {
  id: 'test-subscription-id',
  userId: mockUser.id,
  serviceName: 'Test Service',
  status: 'trial',
  amount: 9.99,
  currency: 'USD',
  billingCycle: 'monthly',
  trialEndsAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
  nextBillingDate: null,
  detectedFrom: 'manual',
  createdAt: new Date(),
  updatedAt: new Date(),
}

// Mock Prisma for unit tests
export function mockPrisma() {
  return {
    user: {
      findUnique: jest.fn(),
      create: jest.fn(),
    },
    subscription: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    },
    reminder: {
      create: jest.fn(),
      update: jest.fn(),
      findUnique: jest.fn(),
    },
  } as unknown as PrismaClient
}
```

**Step 5: Create sample test**

Create: `__tests__/lib/reminders/scheduler.test.ts`

```typescript
import { scheduleTrialReminders } from '@/lib/reminders/scheduler'
import { mockSubscription } from '@/lib/test-utils'

// Mock dependencies
jest.mock('@/lib/db/client', () => ({
  db: {
    reminder: {
      create: jest.fn(),
      update: jest.fn(),
    },
  },
}))

jest.mock('@/lib/queue/client', () => ({
  queues: {
    reminders: {
      add: jest.fn().mockResolvedValue({ id: 'job-123' }),
    },
  },
}))

describe('scheduleTrialReminders', () => {
  it('schedules 3 reminders for a trial subscription', async () => {
    const { db } = require('@/lib/db/client')
    const { queues } = require('@/lib/queue/client')

    db.reminder.create.mockResolvedValue({ id: 'reminder-123' })
    db.reminder.update.mockResolvedValue({})

    await scheduleTrialReminders(mockSubscription as any)

    // Should create 3 reminders (24h, 3h, 1h before)
    expect(db.reminder.create).toHaveBeenCalledTimes(3)
    expect(queues.reminders.add).toHaveBeenCalledTimes(3)
  })

  it('skips scheduling if no trial end date', async () => {
    const { db } = require('@/lib/db/client')

    const subscriptionWithoutTrial = {
      ...mockSubscription,
      trialEndsAt: null,
    }

    await scheduleTrialReminders(subscriptionWithoutTrial as any)

    expect(db.reminder.create).not.toHaveBeenCalled()
  })
})
```

**Step 6: Update package.json**

Modify: `package.json`

Add to scripts:
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```

**Step 7: Run tests**

Run:
```bash
npm test
```

Expected: Tests pass

**Step 8: Commit**

Run:
```bash
git add jest.config.js jest.setup.js lib/test-utils.ts __tests__/ package.json
git commit -m "test: add Jest setup with sample tests"
```

---

## Final Steps

**Step 1: Create final commit**

Run:
```bash
git log --oneline
```

Expected: Should see all commits from this plan

**Step 2: Verify everything works**

Run:
```bash
docker-compose up -d
npx prisma migrate reset --force
tsx lib/services/seed-configs.ts
npm run dev:all
```

Open http://localhost:3000/login

Expected: App loads, can sign in, add subscriptions, see dashboard

**Step 3: Final commit**

Run:
```bash
git add .
git commit -m "feat: complete MVP Phase 1 implementation"
```

---

## Success Criteria

- âœ… User can sign in with magic link
- âœ… User can manually add subscriptions
- âœ… User sees subscriptions on dashboard
- âœ… Reminders are scheduled for trial subscriptions
- âœ… Worker processes reminder jobs
- âœ… Emails are sent via Resend
- âœ… User can view cancellation instructions
- âœ… Tests pass

## Next Steps (Phase 2)

After MVP validation:
1. Gmail OAuth integration
2. Email parsing and auto-detection
3. Push notifications
4. SMS notifications (premium)
5. Auto-cancellation system

---

**Plan Status:** Ready for execution
**Estimated Time:** 6-8 hours for experienced developer
**Tasks:** 12 main tasks, ~60 steps
